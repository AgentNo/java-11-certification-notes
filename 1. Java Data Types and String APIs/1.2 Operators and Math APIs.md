# 1.2 Operators and Math APIs

## 1.2.1 - Arithmetic Operators and Promotion

### Order of Operations
The order of operations follows the mathematical BODMAS model, with additionals for logical operators:

1. Post-Unary (`expr++`, `expr--`)
2. Pre-Unary (`++expr`, `--expr`)
3. Other Unary (`+expr`, `-expr`, `!expr`)
4. Multiplicative (*, /, %)
5. Additive (+, -)
6. Relational (<, >, <=, >=, `instanceof`)
7. Equality (==, !=)
8. Logical (&, ^, |)
9. Logical (short-circuit) (&&, ||)
10. Ternary (`expr ? expr : expr`)
11. Assignment (=, +=, -=, *=, /=, %=)

### Numerical Promotion
Let's take a look at this statement:
```java
byte byteResult = 5 + 3; // 8
```
Any integral literals are intepreted as ints by default. However, what if we wanted to use bytes instead?
```java
byte xByte = 5;
byte yByte = 3;

byte byteResult = xByte + yByte; // Compilation Error
```
Why the compilation error? When a byte is used in an arithmetic operation, Java will attempt to promote it to an int. The above statement, when compiled, is the equivalent of this:
```java
byteResult = (int)xByte + (int)yByte;
```
Obviously the result is an int primitive, which cannot be cast to a byte. The same thing happens with a short:
```java
short xShort = 5;
byte yByte = 3;

short shortResult = xShort + yByte; // Compilation Error
```
Since an int primitive will be returned from either equation, the result can be stored in an int primitive:
```java
int byteResult = xByte + yByte; // 8
int shortResult = xShort + yByte; // 8
```

#### Promotion with Larger Data Types
Another rule is that, when a number of operands are used in arithmetic equations, the operands will be promoted to the largest type before the equation is executed. For example, the following code will throw a compilation error because all types are promoted to longs before execution:
```java
short xShort = 5;
int yInt = 3;
long zLong = 10;

int intResult = xShort + yInt * zLong; // Compilation error
long intResult = xShort + yInt * zLong; // 80
```
The same logic also applies to doubles and floats:
```java
byte xByte = 5;
float yFloat = 3.0f;
double zDouble = 10.0;

float floatResult = xByte + yFloat * zDouble; // Compilation error
double floatResult = xByte + yFloat * zDouble; // 80.0
```

## 1.2.2 Pre- and Post-Unary Operators

### Pre-Unary Operators
These operators will either increment or decrement a variable before the equation is executed, without the need for additional operators or assignments:
```java
int xInt = 1;
++xInt; // 2
--xInt; // 1
```
- Note that pre-Unary operators also work on decimal numbers (e.g. floats and doubles), but will NOT increment the decimal part of the number
- Since pre-Unary operators take precedence, they will be used before the value of the variable is accessed:
```java
int xInt = 4;
int yInt = 7;
int zInt = 3;

int result = ++xInt + yInt + --zInt; // 14
```
- For multiple occurences of the pre-Unary operator in a single equation, each instance of the variable will be calculated in turn.

### Post-Unary Operators
Similar to Pre-Unary, there are increment (++) and decrement (--) operators.
The core difference is that the increment or decrement occurs after the value of the variable has been evaluated in the equation - hence it will be used AFTER the value has been. Example:
```java
int xInt = 1;
result = xInt++ + xInt + xInt++; // 5
```
Since the increment occurs AFTER the value has been used in the equation, this resolves to 5. After this calculation has completed, the value of `xInt` is now 3.

## 1.2.3 Comparision Operators

- There are multiple types of comparison operator:
    - == (Equality)
    - != (None-equality)
    - < (Less than)
    - <= (Less than or equal to)
    - `>` (Greater than)
    - => (Greater than or equal to)
    - `instanceof`
- Usage of these are fairly self-explanatory.
- Note that the relation operators can only be used with numeric types:
```java
int x = 5;
int y = 8;
boolean lol = true;

x < y; // Valid
lol < y // Not Valid
```
- The equality operators can be used on primitives, numbers, objects references (as long as they are the same type, e.g. dates), and booleans:
```java
Date dateA = new Date(0L);
Date dateB = dateA;
Date dateC = new Date (0L);

boolean result = dateA == dateB; // TRUE, same object reference
result = dateA != dateC; // Also TRUE - even if the value matches, these are NOT the same object reference
```
- `instanceof` evaluates the equality of object instances. If the types are the same, or the left operand is a subtype of the right, it returns true:
```java
class ClassA {};
class ClassB extends ClassA {};

ClassA instanceA = new ClassA();
ClassB instanceB = new ClassB();

result = (instanceA instanceof ClassA); // true
result = (instanceB instanceof ClassA); // true
result = (instanceA instanceof ClassB); // false - instanceA is a supertype of B, therefore it is not equal since B is its narrower subtype
```

## 1.2.4 Logical Operators

- The supported logical operators in Java are:
    - & (AND)
    - && (Short-circuit AND)
    - | (OR)
    - || (Short-circuit OR)
    - ^ (Exclusive OR)
    - ! (Negation, unary operator)
- Short circuit operators will only evaluate both sides if needed. For example, AND requires that both operands be true in order for the statement to return TRUE. Using the single `&` operator, Java will check both operands even if the first is false. If using the short-circuit operator (`&&`), FALSE will be immediately returned if the first operand is FALSE.
- Similarly, short-circuit OR (`||`) will immediately return TRUE if the first operand is TRUE. If the first one is false, it will then evaluate the second one.
```java
int xInt = 7;
boolean yBool = false;

boolean result = (xInt++ <= 7) || (yBool = true); // True - yBool is still FALSE since this short-circuit does not evaluate the second operand
```
- A less commonly used operator is `^`, exclusive OR. For this to return true, one side must be FALSE and the other TRUE. Eg:
```java
boolean tru_1 = true;
boolean tru_2 = true;
boolean fls_1 = false;
boolean fls_2 = false;

result = tru_1 ^ tru_2; // false
result = tru_1 ^ fls_1; // true
result = fls_1 ^ fls_2; // false
```
- The ! operator negates the boolean value when evaluated, but does not change the actual value of the variable

## 1.2.5 Ternary Operator
- The ternary opeator is the only Java operator to take three operands
- Basically a shorthand if/else statement, but a bit more restrictive:
- `TEST ? TRUE : FALSE`, e.g:
```java
result = (x <= 3) ? true : false;
```
- Note that the ternary operator doesn't have to strictly be used in assignment and, if you wish to invoke the ire of your team at code review, can be used in an if statement:
```java
if ((x <= 3) ? true : false) {
    // do something
}
```
- Or more sensibly, an operand in another equation:
```java
dValue = ((x <= 3) ? 0.0 : 3.141) * 13;
```
- Note while the ternary operator can accept multiple variable types, both types have to be the same if assigning to a variable if you do not wish Java to cast the result. This isn't a strict requirement though.

## 1.2.6 Positive and Negative Unary Operators
- `+` and `-` are postive and negative. No surprises there.
- Just be wary of trick questions on the exam
```java
int x = 5 * -3 // -15
double y = -6 + 9.13 // 3.13000

x = 5;
y = --x * -3 + -x; // -16.0
```